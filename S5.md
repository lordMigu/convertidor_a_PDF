## 1. PROMPT BACKEND
Actúa como un Ingeniero de Seguridad en Python. Necesito implementar la lógica de Firma Electrónica y Validación en mi API de FastAPI para la 'Semana 5' de mi proyecto.

Librerías: Usa pyHanko (específicamente pyhanko.sign y pyhanko.pdf_utils).

Requerimiento 1: Endpoint de Firma (POST /documents/sign)

Inputs:

document_id (Form/Query): ID del documento PDF ya guardado en el servidor que se va a firmar.

p12_file (UploadFile): El archivo de certificado (.p12 o .pfx) que sube el usuario.

password (Form): La contraseña del certificado.

Lógica:

Carga el PDF original desde el disco (usando el document_id).

Lee el archivo P12 en memoria (bytes) y desbloquéalo con la contraseña usando pyhanko.sign.fields.SimpleSigner.

Realiza una firma no visible o con un widget de firma simple en el PDF.

Guarda el resultado como una nueva versión del documento (ej. v1.2) en la base de datos y disco.

Importante: Maneja la excepción si la contraseña es incorrecta.

Requerimiento 2: Endpoint de Validación (POST /documents/validate)

Inputs: Un archivo PDF (UploadFile).

Lógica:

Usa pyhanko.sign.validation para leer las firmas incrustadas.

Devuelve un JSON con:

is_valid: Booleano (Integridad del hash).

signer_name: Nombre extraído del certificado (Common Name).

timestamp: Fecha de la firma.

trusted: Booleano. Para esto, intenta validar contra una lista de confianza vacía (validación matemática/ad-hoc) por ahora.

Nota: El código debe ser asíncrono, pero como la firma es intensiva en CPU, usa run_in_threadpool si es necesario para no bloquear el event loop.

## 2. Prompt para el Frontend
Actúa como un experto en Frontend Web. Necesito crear la interfaz y la lógica de conexión para firmar documentos digitalmente consumiendo mi API de FastAPI.

Escenario: El usuario ya seleccionó un documento de su lista (tengo el documentId). Ahora debe subir su certificado .p12 y poner su contraseña.

Requerimientos de Código (JavaScript/Logic):

Genera el código para un formulario HTML que tenga:

Un input tipo file que acepte solo .p12 y .pfx.

Un input tipo password.

Un botón "Firmar Documento".

Genera la función de JavaScript (usando fetch o axios) para el evento onSubmit:

Debe crear un objeto FormData.

Debe adjuntar el document_id, el archivo p12 y el password.

Debe enviar una petición POST a /documents/sign con el header Content-Type: multipart/form-data (o dejar que el navegador lo ponga).

Manejo de Errores: Muestra cómo capturar si el backend responde '400 Bad Request' (contraseña incorrecta) para mostrar una alerta al usuario.

Bonus: Dame también un pequeño snippet para el formulario de validación (subir PDF -> mostrar resultado JSON en pantalla).